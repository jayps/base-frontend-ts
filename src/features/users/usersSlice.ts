import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit';
import {RootState} from '../../app/store';
import {User, UserListRequest} from "../../models/User";
import {deleteUser, fetchUser, getUsersList, saveUser} from "./usersAPI";
import {DataTableFilterSetting} from "../../components/data-table/DataTable";

export interface UsersState {
    loading: boolean;
    saving: boolean;
    error?: any | null;
    users: User[];
    totalUsers: number;
    currentPage: number;
    filters: DataTableFilterSetting[];
    search?: string | null;
    sorting?: string | null;
    nextPage?: string | null;
    previousPage?: string | null;
    currentUser?: User | null,
    userSaved: boolean,
    userDeleted: boolean
}

const initialState: UsersState = {
    loading: true,
    saving: false,
    error: null,
    users: [],
    totalUsers: 0,
    currentPage: 1,
    userSaved: false,
    userDeleted: false,
    filters: []
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getUsersListAsync = createAsyncThunk(
    'users/getUsersList',
    async (requestParams: UserListRequest, thunkAPI) => {
        try {
            const {data} = await getUsersList(requestParams);

            return data;
        } catch (err) {
            return thunkAPI.rejectWithValue(err);
        }
    }
);

export const fetchUserAsync = createAsyncThunk(
    'users/getUser',
    async (id: string, thunkAPI) => {
        try {
            const {data} = await fetchUser(id);

            return data;
        } catch (err) {
            return thunkAPI.rejectWithValue(err);
        }
    }
);

export const saveUserAsync = createAsyncThunk(
    'users/save',
    async (user: User, thunkAPI) => {
        try {
            const {data} = await saveUser(user);

            return data;
        } catch (err) {
            return thunkAPI.rejectWithValue(err);
        }
    }
);

export const deleteUserAsync = createAsyncThunk(
    'users/delete',
    async (id: string, thunkAPI) => {
        try {
            await deleteUser(id);
        } catch (err) {
            return thunkAPI.rejectWithValue(err);
        }
    }
);

export const usersSlice = createSlice({
    name: 'users',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setCurrentPage: (state, action) => {
            state.currentPage = action.payload;
        },
        setUserFilters: (state, action: PayloadAction<DataTableFilterSetting>) => {
            const currentFilters = state.filters.filter(f => f.name !== action.payload.name);
            if (action.payload.value) {
                currentFilters.push(action.payload);
            }

            state.filters = currentFilters;
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(getUsersListAsync.pending, (state) => {
                state.loading = true;
                state.error = null;
                state.users = [];
                state.currentUser = null;
                state.userSaved = false;
                state.userDeleted = false;
            })
            .addCase(getUsersListAsync.fulfilled, (state, action) => {
                state.loading = false;
                state.users = action.payload.results;
                state.totalUsers = action.payload.count;
                state.nextPage = action.payload.next;
                state.previousPage = action.payload.previous;
            })
            .addCase(getUsersListAsync.rejected, (state, action) => {
                state.loading = false;
                state.users = [];
                state.error = action.payload;
            })
            .addCase(fetchUserAsync.pending, (state) => {
                state.loading = true;
                state.error = null;
                state.currentUser = null;
            })
            .addCase(fetchUserAsync.fulfilled, (state, action) => {
                state.loading = false;
                state.currentUser = action.payload;
            })
            .addCase(fetchUserAsync.rejected, (state, action) => {
                state.loading = false;
                state.currentUser = null;
                state.error = action.payload;
            })
            .addCase(saveUserAsync.pending, (state) => {
                state.saving = true;
                state.error = null;
            })
            .addCase(saveUserAsync.fulfilled, (state, action) => {
                state.saving = false;
                state.userSaved = true;
            })
            .addCase(saveUserAsync.rejected, (state, action) => {
                state.saving = false;
                state.error = action.payload;
            })
            .addCase(deleteUserAsync.pending, (state) => {
                state.loading = true;
                state.error = null;
                state.userDeleted = false;
            })
            .addCase(deleteUserAsync.fulfilled, (state, action) => {
                state.loading = false;
                state.userDeleted = true;
            })
            .addCase(deleteUserAsync.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload;
            })
    },
});

export const {setCurrentPage, setUserFilters} = usersSlice.actions;

export const selectUsers = (state: RootState) => state.users;

export default usersSlice.reducer;
