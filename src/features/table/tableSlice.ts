import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit';
import {RootState} from '../../app/store';
import {DataTableFilterSetting} from "../../components/data-table/DataTable";
import {DataModel, SortSettings} from "../../models/DataModel";
import {DataModelRequest} from "../../models/Request";
import {deleteTableDataItem, getTableDataList} from "./tableAPI";

export interface EndpointFilters {
    endpoint: string;
    filters: DataTableFilterSetting[];
}

export interface EndpointFilterPayload {
    endpoint: string;
    filter: DataTableFilterSetting;
}

export interface TableState {
    loading: boolean;
    saving: boolean;
    error?: any | null;
    records: DataModel[];
    totalRecords: number;
    currentPage: number;
    filters: EndpointFilters[];
    search?: string | null;
    sorting?: SortSettings;
    nextPage?: string | null;
    previousPage?: string | null;
    recordDeleted?: boolean;
}

const initialState: TableState = {
    loading: true,
    saving: false,
    error: null,
    records: [],
    totalRecords: 0,
    currentPage: 1,
    filters: []
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getTableDataListAsync = createAsyncThunk(
    'table/getTableDataList',
    async (requestParams: DataModelRequest, thunkAPI) => {
        try {
            const {data} = await getTableDataList(requestParams);

            return data;
        } catch (err) {
            return thunkAPI.rejectWithValue(err);
        }
    }
);

export const deleteTableDataItemAsync = createAsyncThunk(
    'table/deleteTableDataItem',
    async ({endpoint, id}: any, thunkAPI) => {
        try {
            await deleteTableDataItem(endpoint, id);
        } catch (err) {
            return thunkAPI.rejectWithValue(err);
        }
    }
);

export const tableSlice = createSlice({
    name: 'users',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setTablePage: (state, action) => {
            state.currentPage = action.payload;
        },
        setTableFilters: (state, action: PayloadAction<EndpointFilterPayload>) => {
            const endpointFilters = state.filters.find(f => f.endpoint === action.payload.endpoint) || {
                endpoint: action.payload.endpoint,
                filters: []
            };
            endpointFilters.filters = endpointFilters.filters.filter(f => f.name !== action.payload.filter.name);
            if (action.payload.filter.value) {
                endpointFilters.filters.push(action.payload.filter);
            }

            const existingFiltersExcludingUpdates = state.filters.filter(f => f.endpoint !== action.payload.endpoint);

            state.filters = [...existingFiltersExcludingUpdates, endpointFilters];
            state.currentPage = 1;
        },
        setSearch: (state, action) => {
            state.search = action.payload;
            state.currentPage = 1;
        },
        setSorting: (state, action) => {
            state.sorting = action.payload;
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(getTableDataListAsync.pending, (state) => {
                state.loading = true;
                state.error = null;
                state.records = [];
                state.totalRecords = 0;
                state.recordDeleted = false;
            })
            .addCase(getTableDataListAsync.fulfilled, (state, action) => {
                state.loading = false;
                state.records = action.payload.results;
                state.totalRecords = action.payload.count;
                state.nextPage = action.payload.next;
                state.previousPage = action.payload.previous;
                state.error = null;
            })
            .addCase(getTableDataListAsync.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload;
            })
            .addCase(deleteTableDataItemAsync.pending, (state) => {
                state.loading = true;
                state.error = null;
                state.recordDeleted = false;
            })
            .addCase(deleteTableDataItemAsync.fulfilled, (state) => {
                state.loading = false;
                state.recordDeleted = true;
            })
            .addCase(deleteTableDataItemAsync.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload;
            })
    },
});

export const {setTablePage, setTableFilters, setSearch, setSorting} = tableSlice.actions;

export const selectTable = (state: RootState) => state.table;

export default tableSlice.reducer;
